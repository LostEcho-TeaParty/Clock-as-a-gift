C51 COMPILER V9.56.0.0   DS1302_2_0                                                        01/30/2018 18:53:56 PAGE 1   


C51 COMPILER V9.56.0.0, COMPILATION OF MODULE DS1302_2_0
OBJECT MODULE PLACED IN .\Objects\ds1302 2.0.obj
COMPILER INVOKED BY: E:\Keil_v5\C51\BIN\C51.EXE ds1302 2.0.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listing
                    -s\ds1302 2.0.lst) TABS(2) OBJECT(.\Objects\ds1302 2.0.obj)

line level    source

   1          #include<reg52.h>     //包含单片机寄存器的头文件
   2          #include<intrins.h>   //包含_nop_()函数定义的头文件
   3          unsigned char code digit[10]={"0123456789"};   //定义字符数组显示数字
   4          sbit SCLK=P3^5;   //位定义1302芯片的接口，时钟输出端口定义在P1.0引脚
   5          sbit DATA=P3^4;   //位定义1302芯片的接口，数据输出端定义在P1.1引脚
   6          sbit RST=P3^3;    //位定义1302芯片的接口，复位端口定义在P1.2引脚
   7          /*****************************************************
   8          函数功能：延时若干微秒
   9          入口参数：n
  10          ***************************************************/ 
  11          void delaynus(unsigned char n)
  12          {
  13   1       unsigned char i;
  14   1       for(i=0;i<n;i++);
  15   1      }
  16          
  17          /*****************************************************
  18          函数功能：向1302写一个字节数据
  19          入口参数：x
  20          ***************************************************/ 
  21          void Write1302(unsigned char dat)
  22          {
  23   1        unsigned char i; 
  24   1        SCLK=0;            //拉低SCLK，为脉冲上升沿写入数据做好准备
  25   1        delaynus(2);       //稍微等待，使硬件做好准备
  26   1        for(i=0;i<8;i++)      //连续写8个二进制位数据
  27   1          {
  28   2             DATA=dat&0x01;    //取出dat的第0位数据写入1302  低位在前，高位在后
  29   2           delaynus(2);       //稍微等待，使硬件做好准备
  30   2           SCLK=1;           //上升沿写入数据
  31   2           delaynus(2);      //稍微等待，使硬件做好准备
  32   2           SCLK=0;           //重新拉低SCLK，形成脉冲
  33   2           dat>>=1;          //将dat的各数据位右移1位，准备写入下一个数据位
  34   2          }
  35   1        
  36   1       }
  37          /*****************************************************
  38          函数功能：根据命令字，向1302写一个字节数据
  39          入口参数：Cmd，储存命令字；dat，储存待写的数据
  40          ***************************************************/ 
  41          void WriteSet1302(unsigned char Cmd,unsigned char dat)
  42           {    
  43   1              RST=0;           //禁止数据传递
  44   1              SCLK=0;          //确保写数居前SCLK被拉低
  45   1            RST=1;           //启动数据传输
  46   1            delaynus(2);     //稍微等待，使硬件做好准备
  47   1            Write1302(Cmd);  //写入命令字
  48   1            Write1302(dat);  //写数据
  49   1            SCLK=1;          //将时钟电平置于高电平状态
  50   1            RST=0;           //禁止数据传递
  51   1       }
  52          /*****************************************************
  53          函数功能：从1302读一个字节数据
  54          入口参数：x
C51 COMPILER V9.56.0.0   DS1302_2_0                                                        01/30/2018 18:53:56 PAGE 2   

  55          ***************************************************/ 
  56           unsigned char Read1302(void)
  57           {
  58   1          unsigned char i,dat;
  59   1        delaynus(2);       //稍微等待，使硬件做好准备
  60   1        for(i=0;i<8;i++)   //连续读8个二进制位数据
  61   1         {   dat>>=1;
  62   2           if(DATA==1)    //如果读出的数据是1
  63   2           dat|=0x80;    //将1取出，写在dat的最高位
  64   2           SCLK=1;       //将SCLK置于高电平，为下降沿读出
  65   2           delaynus(2);  //稍微等待
  66   2           SCLK=0;       //拉低SCLK，形成脉冲下降沿
  67   2           delaynus(2);  //稍微等待
  68   2          }  
  69   1        return dat;        //将读出的数据返回
  70   1      }  
  71          /*****************************************************
  72          函数功能：根据命令字，从1302读取一个字节数据
  73          入口参数：Cmd
  74          ***************************************************/ 
  75          unsigned char  ReadSet1302(unsigned char Cmd)
  76           {
  77   1        unsigned char dat;
  78   1        RST=0;                 //拉低RST
  79   1        SCLK=0;                //确保写数居前SCLK被拉低
  80   1        RST=1;                 //启动数据传输
  81   1        Write1302(Cmd);       //写入命令字
  82   1        dat=Read1302();       //读出数据
  83   1        SCLK=1;              //将时钟电平置于已知状态
  84   1        RST=0;               //禁止数据传递
  85   1        return dat;          //将读出的数据返回
  86   1      }
  87          /*****************************************************
  88          函数功能： 1302进行初始化设置
  89          ***************************************************/ 
  90          void Init_DS1302(void)
  91          { 
  92   1      //  unsigned char flag;
  93   1      //   
  94   1      //    flag= ReadSet1302(0x81);
  95   1      //  if(flag&0x80) {      //判断时钟芯片是否关闭
  96   1      //     WriteSet1302(0x8E,0x00);                 //根据写状态寄存器命令字，写入不保护指令 
  97   1      //    WriteSet1302(0x80,((55/10)<<4|(55%10)));   //根据写秒寄存器命令字，写入秒的初始值
  98   1      //  WriteSet1302(0x82,((59/10)<<4|(59%10)));   //根据写分寄存器命令字，写入分的初始值
  99   1      //  WriteSet1302(0x84,((23/10)<<4|(23%10))); //根据写小时寄存器命令字，写入小时的初始值
 100   1      //  WriteSet1302(0x86,((18/10)<<4|(18%10))); //根据写日寄存器命令字，写入日的初始值
 101   1      //  WriteSet1302(0x88,((6/10)<<4|(6%10))); //根据写月寄存器命令字，写入月的初始值
 102   1      //  WriteSet1302(0x8c,((9/10)<<4|(9%10)));  //根据写年寄存器命令字，写入年的初始值
 103   1      //  WriteSet1302(0x90,0xa5);                //打开充电功能 选择2K电阻充电方式
 104   1      //  WriteSet1302(0x8E,0x80);         //根据写状态寄存器命令字，写入保护指令
 105   1      //  }
 106   1      
 107   1        }
 108            //如果不想每次都初始化时间，也就是掉电后还想让时钟继续走时的话 就用上面的语句
 109          
 110          
 111            /*--------------------这是每次都初始化的语句-----------------*/
 112           
 113             WriteSet1302(0x8E,0x00);                 //根据写状态寄存器命令字，写入不保护指令
*** ERROR C141 IN LINE 113 OF ds1302 2.0.c: syntax error near '0x8E'
*** ERROR C231 IN LINE 113 OF ds1302 2.0.c: '_WriteSet1302': redefinition
 114             WriteSet1302(0x80,((55/10)<<4|(55%10)));   //根据写秒寄存器命令字，写入秒的初始值
C51 COMPILER V9.56.0.0   DS1302_2_0                                                        01/30/2018 18:53:56 PAGE 3   

*** ERROR C141 IN LINE 114 OF ds1302 2.0.c: syntax error near '0x80'
*** ERROR C141 IN LINE 114 OF ds1302 2.0.c: syntax error near '<<'
*** ERROR C141 IN LINE 114 OF ds1302 2.0.c: syntax error near '55'
 115          
 116            WriteSet1302(0x82,((59/10)<<4|(59%10)));   //根据写分寄存器命令字，写入分的初始值
*** ERROR C141 IN LINE 116 OF ds1302 2.0.c: syntax error near '0x82'
*** ERROR C141 IN LINE 116 OF ds1302 2.0.c: syntax error near '<<'
*** ERROR C141 IN LINE 116 OF ds1302 2.0.c: syntax error near '59'
 117          
 118            WriteSet1302(0x84,((23/10)<<4|(23%10))); //根据写小时寄存器命令字，写入小时的初始值
*** ERROR C141 IN LINE 118 OF ds1302 2.0.c: syntax error near '0x84'
*** ERROR C141 IN LINE 118 OF ds1302 2.0.c: syntax error near '<<'
*** ERROR C141 IN LINE 118 OF ds1302 2.0.c: syntax error near '23'
 119          
 120            WriteSet1302(0x86,((18/10)<<4|(18%10))); //根据写日寄存器命令字，写入日的初始值
*** ERROR C141 IN LINE 120 OF ds1302 2.0.c: syntax error near '0x86'
*** ERROR C141 IN LINE 120 OF ds1302 2.0.c: syntax error near '<<'
*** ERROR C141 IN LINE 120 OF ds1302 2.0.c: syntax error near '18'
 121          
 122            WriteSet1302(0x88,((6/10)<<4|(6%10))); //根据写月寄存器命令字，写入月的初始值
*** ERROR C141 IN LINE 122 OF ds1302 2.0.c: syntax error near '0x88'
*** ERROR C141 IN LINE 122 OF ds1302 2.0.c: syntax error near '<<'
*** ERROR C141 IN LINE 122 OF ds1302 2.0.c: syntax error near '6'
 123          
 124            WriteSet1302(0x8c,((9/10)<<4|(9%10)));   //根据写年寄存器命令字，写入年的初始值
*** ERROR C141 IN LINE 124 OF ds1302 2.0.c: syntax error near '0x8c'
*** ERROR C141 IN LINE 124 OF ds1302 2.0.c: syntax error near '<<'
*** ERROR C141 IN LINE 124 OF ds1302 2.0.c: syntax error near '9'
 125          
 126            WriteSet1302(0x90,0xa5);                //打开充电功能 选择2K电阻充电方式
*** ERROR C141 IN LINE 126 OF ds1302 2.0.c: syntax error near '0x90'
*** ERROR C231 IN LINE 126 OF ds1302 2.0.c: '_WriteSet1302': redefinition
 127          
 128            WriteSet1302(0x8E,0x80);              //根据写状态寄存器命令字，写入保护指令
*** ERROR C141 IN LINE 128 OF ds1302 2.0.c: syntax error near '0x8E'
*** ERROR C231 IN LINE 128 OF ds1302 2.0.c: '_WriteSet1302': redefinition
 129          
 130                            
 131          
 132          
 133          
 134          /*******************************************************************************
 135          以下是对液晶模块的操作程序
 136          *******************************************************************************/
 137          sbit RS=P2^3;           //寄存器选择位，将RS位定义为P2.0引脚
 138          //sbit RW=P2^1;           //读写选择位，将RW位定义为P2.1引脚
 139          sbit E=P2^2;            //使能信号位，将E位定义为P2.2引脚
 140          //sbit BF=P0^7;           //忙碌标志位，，将BF位定义为P0.7引脚
 141          /*****************************************************
 142          函数功能：延时1ms
 143          (3j+2)*i=(3×33+2)×10=1010(微秒)，可以认为是1毫秒
 144          ***************************************************/
 145          void delay1ms()
 146          {
 147   1          unsigned char i,j;  
 148   1         for(i=0;i<10;i++)
 149   1          for(j=0;j<33;j++)
 150   1           ;     
 151   1       }
 152          /*****************************************************
 153          函数功能：延时若干毫秒
 154          入口参数：n
C51 COMPILER V9.56.0.0   DS1302_2_0                                                        01/30/2018 18:53:56 PAGE 4   

 155          ***************************************************/
 156           void delaynms(unsigned char n)
 157           {
 158   1         unsigned char i;
 159   1        for(i=0;i<n;i++)
 160   1           delay1ms();
 161   1       }
 162          /*****************************************************
 163          函数功能：判断液晶模块的忙碌状态
 164          返回值：result。result=1，忙碌;result=0，不忙
 165          ***************************************************/
 166          //bit BusyTest(void)
 167          //  {
 168          //        bit result;
 169          //      RS=0;       //根据规定，RS为低电平，RW为高电平时，可以读状态
 170          //      RW=1;
 171          //      E=1;        //E=1，才允许读写
 172          //      _nop_();   //空操作
 173          //      _nop_();
 174          //      _nop_(); 
 175          //      _nop_();   //空操作四个机器周期，给硬件反应时间 
 176          //      result=BF;  //将忙碌标志电平赋给result
 177          //    E=0;         //将E恢复低电平
 178          //    return result;
 179          //  }
 180          /*****************************************************
 181          函数功能：将模式设置指令或显示地址写入液晶模块
 182          入口参数：dictate
 183          ***************************************************/
 184          void WriteInstruction (unsigned char dictate)
 185          {   
 186   1      //      while(BusyTest()==1);   //如果忙就等待
 187   1         RS=0;                  //根据规定，RS和R/W同时为低电平时，可以写入指令
 188   1      //   RW=0;   
 189   1         E=0;                   //E置低电平(根据表8-6，写指令时，E为高脉冲，
 190   1                                 // 就是让E从0到1发生正跳变，所以应先置"0"
 191   1         _nop_();
 192   1         _nop_();               //空操作两个机器周期，给硬件反应时间
 193   1         P0=dictate;            //将数据送入P0口，即写入指令或地址
 194   1         _nop_();
 195   1         _nop_();
 196   1         _nop_();
 197   1         _nop_();               //空操作四个机器周期，给硬件反应时间
 198   1         E=1;                   //E置高电平
 199   1         _nop_();
 200   1         _nop_();
 201   1         _nop_();
 202   1         _nop_();               //空操作四个机器周期，给硬件反应时间
 203   1          E=0;                  //当E由高电平跳变成低电平时，液晶模块开始执行命令
 204   1       }
 205          /*****************************************************
 206          函数功能：指定字符显示的实际地址
 207          入口参数：x
 208          ***************************************************/
 209           void WriteAddress(unsigned char x)
 210           {
 211   1           WriteInstruction(x|0x80); //显示位置的确定方法规定为"80H+地址码x"
 212   1       }
 213          /*****************************************************
 214          函数功能：将数据(字符的标准ASCII码)写入液晶模块
 215          入口参数：y(为字符常量)
 216          ***************************************************/
C51 COMPILER V9.56.0.0   DS1302_2_0                                                        01/30/2018 18:53:56 PAGE 5   

 217           void WriteData(unsigned char y)
 218           {
 219   1      //   while(BusyTest()==1);  
 220   1          RS=1;           //RS为高电平，RW为低电平时，可以写入数据
 221   1      //    RW=0;
 222   1          E=0;            //E置低电平(根据表8-6，写指令时，E为高脉冲，
 223   1                           // 就是让E从0到1发生正跳变，所以应先置"0"
 224   1          P0=y;           //将数据送入P0口，即将数据写入液晶模块
 225   1          _nop_();
 226   1          _nop_();
 227   1          _nop_();
 228   1           _nop_();       //空操作四个机器周期，给硬件反应时间
 229   1          E=1;           //E置高电平
 230   1          _nop_();
 231   1          _nop_();
 232   1          _nop_();
 233   1         _nop_();        //空操作四个机器周期，给硬件反应时间
 234   1         E=0;            //当E由高电平跳变成低电平时，液晶模块开始执行命令
 235   1       }
 236          /*****************************************************
 237          函数功能：对LCD的显示模式进行初始化设置
 238          ***************************************************/
 239          void LcdInitiate(void)
 240          {
 241   1          delaynms(15);               //延时15ms，首次写指令时应给LCD一段较长的反应时间
 242   1          WriteInstruction(0x38);     //显示模式设置：16×2显示，5×7点阵，8位数据接口
 243   1        delaynms(5);                //延时5ms　，给硬件一点反应时间
 244   1          WriteInstruction(0x38);
 245   1        delaynms(5);               //延时5ms　，给硬件一点反应时间
 246   1        WriteInstruction(0x38);     //连续三次，确保初始化成功
 247   1        delaynms(5);               //延时5ms　，给硬件一点反应时间
 248   1        WriteInstruction(0x0c);     //显示模式设置：显示开，无光标，光标不闪烁
 249   1        delaynms(5);               //延时5ms　，给硬件一点反应时间
 250   1        WriteInstruction(0x06);     //显示模式设置：光标右移，字符不移
 251   1        delaynms(5);                //延时5ms　，给硬件一点反应时间
 252   1        WriteInstruction(0x01);     //清屏幕指令，将以前的显示内容清除
 253   1        delaynms(5);             //延时5ms　，给硬件一点反应时间
 254   1      
 255   1       }
 256          /**************************************************************
 257          以下是1302数据的显示程序
 258          **************************************************************/
 259          /*****************************************************
 260          函数功能：显示秒
 261          入口参数：x
 262          ***************************************************/ 
 263          void DisplaySecond(unsigned char x)
 264          {
 265   1       unsigned char i,j;     //j,k分别储存十位和个位
 266   1        i=x/10;//取十位
 267   1        j=x%10;//取个位     
 268   1        WriteAddress(0x49);    //写显示地址,将在第2行第7列开始显示
 269   1        WriteData(digit[i]);    //将百位数字的字符常量写入LCD
 270   1        WriteData(digit[j]);    //将十位数字的字符常量写入LCD
 271   1        delaynms(50);         //延时1ms给硬件一点反应时间    
 272   1       }
 273          
 274          /*****************************************************
 275          函数功能：显示分钟
 276          入口参数：x
 277          ***************************************************/ 
 278          void DisplayMinute(unsigned char x)
C51 COMPILER V9.56.0.0   DS1302_2_0                                                        01/30/2018 18:53:56 PAGE 6   

 279          {
 280   1       unsigned char i,j;     //j,k十位和个位
 281   1        i=x/10;//取十位
 282   1        j=x%10;//取个位     
 283   1        WriteAddress(0x46);    //写显示地址,将在第2行第7列开始显示
 284   1        WriteData(digit[i]);    //将百位数字的字符常量写入LCD
 285   1        WriteData(digit[j]);    //将十位数字的字符常量写入LCD
 286   1        delaynms(50);         //延时1ms给硬件一点反应时间    
 287   1       }
 288          /*****************************************************
 289          函数功能：显示小时
 290          入口参数：x
 291          ***************************************************/ 
 292          void DisplayHour(unsigned char x)
 293          {
 294   1       unsigned char i,j;     //j,k十位和个位
 295   1        i=x/10;//取十位
 296   1        j=x%10;//取个位     
 297   1        WriteAddress(0x43);    //写显示地址,将在第2行第7列开始显示
 298   1        WriteData(digit[i]);    //将百位数字的字符常量写入LCD
 299   1        WriteData(digit[j]);    //将十位数字的字符常量写入LCD
 300   1        delaynms(50);         //延时1ms给硬件一点反应时间    
 301   1       }
 302           /*****************************************************
 303          函数功能：显示日
 304          入口参数：x
 305          ***************************************************/ 
 306          void DisplayDay(unsigned char x)
 307          {
 308   1        unsigned char i,j;     //j,k十位和个位
 309   1        i=x/10;//取十位
 310   1        j=x%10;//取个位     
 311   1        WriteAddress(0x0c);    //写显示地址,将在第2行第7列开始显示
 312   1        WriteData(digit[i]);    //将十位数字的字符常量写入LCD
 313   1        WriteData(digit[j]);    //将个位数字的字符常量写入LCD
 314   1        delaynms(50);         //延时1ms给硬件一点反应时间    
 315   1       }
 316           /*****************************************************
 317          函数功能：显示月
 318          入口参数：x
 319          ***************************************************/ 
 320          void DisplayMonth(unsigned char x)
 321          {
 322   1       unsigned char i,j;     //j,k分别储存十位和个位
 323   1        i=x/10;//取十位
 324   1        j=x%10;//取个位     
 325   1        WriteAddress(0x09);    //写显示地址,将在第2行第7列开始显示
 326   1        WriteData(digit[i]);    //将十位位数字的字符常量写入LCD
 327   1        WriteData(digit[j]);    //将个位数字的字符常量写入LCD
 328   1        delaynms(50);         //延时1ms给硬件一点反应时间    
 329   1       }
 330          /*****************************************************
 331          函数功能：显示年
 332          入口参数：x
 333          ***************************************************/ 
 334          void DisplayYear(unsigned char x)
 335          {
 336   1       unsigned char i,j;     //j,k分别储存十位和个位
 337   1        i=x/10;//取十位
 338   1        j=x%10;//取个位     
 339   1        WriteAddress(0x06);    //写显示地址,将在第2行第7列开始显示
 340   1        WriteData(digit[i]);    //将十位位数字的字符常量写入LCD
C51 COMPILER V9.56.0.0   DS1302_2_0                                                        01/30/2018 18:53:56 PAGE 7   

 341   1        WriteData(digit[j]);    //将个位数字的字符常量写入LCD
 342   1        delaynms(50);         //延时1ms给硬件一点反应时间    
 343   1       }
 344          
 345          /*****************************************************
 346          函数功能：主函数
 347          ***************************************************/ 
 348          void main(void)
 349          {
 350   1        unsigned char second,minute,hour,day,month,year;      //分别储存苗、分、小时，日，月，年
 351   1        unsigned char ReadValue;   //储存从1302读取的数据
 352   1        LcdInitiate();             //将液晶初始化
 353   1        WriteAddress(0x01);  //写Date的显示地址,将在第1行第2列开始显示
 354   1        WriteData('D');      //将字符常量写入LCD
 355   1        WriteData('a');      //将字符常量写入LCD
 356   1        WriteData('t');      //将字符常量写入LCD
 357   1        WriteData('e');      //将字符常量写入LCD
 358   1        WriteData(':');      //将字符常量写入LCD
 359   1        WriteAddress(0x08);  //写年月分隔符的显示地址， 显示在第1行第9列
 360   1        WriteData('-');      //将字符常量写入LCD
 361   1        WriteAddress(0x0b);  //写月日分隔符的显示地址， 显示在第1行第12列
 362   1        WriteData('-');      //将字符常量写入LCD
 363   1        WriteAddress(0x45);  //写小时与分钟分隔符的显示地址， 显示在第2行第6列
 364   1        WriteData(':');      //将字符常量写入LCD
 365   1        WriteAddress(0x48);  //写分钟与秒分隔符的显示地址， 显示在第2行第9列
 366   1        WriteData(':');      //将字符常量写入LCD
 367   1        Init_DS1302();       //将1302初始化 
 368   1        while(1)
 369   1          {
 370   2          ReadValue = ReadSet1302(0x81);   //从秒寄存器读数据
 371   2           second=((ReadValue&0x70)>>4)*10 + (ReadValue&0x0F);//将读出数据转化
 372   2          DisplaySecond(second);          //显示秒
 373   2          ReadValue = ReadSet1302(0x83);  //从分寄存器读
 374   2           minute=((ReadValue&0x70)>>4)*10 + (ReadValue&0x0F); //将读出数据转化
 375   2          DisplayMinute(minute);         //显示分
 376   2           ReadValue = ReadSet1302(0x85);  //从分寄存器读
 377   2           hour=((ReadValue&0x70)>>4)*10 + (ReadValue&0x0F); //将读出数据转化
 378   2          DisplayHour(hour);               //显示小时
 379   2           ReadValue = ReadSet1302(0x87);  //从分寄存器读
 380   2           day=((ReadValue&0x70)>>4)*10 + (ReadValue&0x0F); //将读出数据转化
 381   2          DisplayDay(day);                //显示日
 382   2          ReadValue = ReadSet1302(0x89);  //从分寄存器读
 383   2           month=((ReadValue&0x70)>>4)*10 + (ReadValue&0x0F); //将读出数据转化
 384   2          DisplayMonth(month);            //显示月
 385   2          ReadValue = ReadSet1302(0x8d);  //从分寄存器读
 386   2           year=((ReadValue&0xf0)>>4)*10 + (ReadValue&0x0F); //将读出数据转化
 387   2          DisplayYear(year);              //显示年
 388   2         }
 389   1      }

C51 COMPILATION COMPLETE.  0 WARNING(S),  24 ERROR(S)
